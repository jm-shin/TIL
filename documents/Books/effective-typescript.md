## 아이템1. 타입스크립트와 자바스크립트의 관계 이해하기

- 명시적으로 states를 선언하여 의도를 분명하게 해야한다. 그래야 오류가 어디서 발생했는지 찾을 수 있고, 제시된 해결책도 올바르다.
- 자바스크립트의 런타임 동작을 모델링하는 것은 타입스크립트 타입 시스템의 기본 원칙.
- TS는 JS 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다. 그러나 모든 오류를 찾아내리라 기대해선 안됨. 타입 체커를 통과하면서도 런타임 오류를
  발생시키는 코드는 충분히 존재할 수 있음.

## 아이템2. 타입스크립트의 설정 이해하기

- 가급적 설정 파일을 사용. 그래야 TS를 어떻게 사용할 계획인지 동료들과 다른 도구들이 알 수 있음. 설정 파일은 ts --init 명령어로 생성.
- 커맨드 라인보다 tsconfig.json을 사용하자.
- TS는 타입 정보를 가질 때 가장 효과적이기에 가급적 noImplicitAny를 설정해야 한다.
- "undefined는 객체가 아닙니다." 같은 런타임 오류를 방지하기 위해 NullChecks를 설정하는 것이 좋다.
- TS에 엄격한 체크를 원한다면 strict 설정을 고려해봐야 한다.

## 아이템3. 코드의 생성과 타입이 관계없음을 이해하기

큰 틀에서 보면 ts 컴파일러는 두 가지 역할을 수행.

- 최신 ts/js를 브라우저에서 동작할 수 있도록 구버전의 js로 트랜스파일
- 코드의 타입 오류를 체크   
  위 두 가지는 완벽히 독립적이라는 것. ts -> js로 변환될 때 코드 내의 타입에는 영향을 주지 않음.
- 즉, **타입 오류가 있는 코드도 컴파일이 가능**. ts에 오류는 c나 java같은 언어의 경고(warning)와 비슷함. 문제가 될 만한 부분을 알려 주지만 그렇다고 빌드를 멈추지는 않음.

### 요약

- **런타임에는 타입 체크가 불가능함**
- 타입 연산은 런타임에 영향을 주지 않음.
- 런타임 타입은 선언된 타입과 다를 수 있음.
- 타입스크립트 타입으로는 함수를 오버로드할 수 없다.
- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

## 아이템4. 구조적 타이핑에 익숙해지기

- 자바스크립트가 덕 타이핑 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 합니다. 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성을 가지고 있을 것.
- 클래스 역시 구조적 타이핑 규칙을 따름. 클래스의 인스턴스가 예상과 다를 수 있다.
- 구조적 타이핑을 이용하면 테스팅을 수월하게 할 수 있음.

## 아이템5. any 타입 지양하기

TS는 코드에 타입을 조금씩 추가할 수 있기 때문에 **점진적**이며, 언제든지 타입체커를 해제할 수 있기 때문에 **선택적**입니다. 타입체커가 찾아낸 오류는 as any를 추가해 해결 가능함. 그러나 특별한
경우를 제외하고 사용 x.

- any 타입에는 타입 안정성이 없다.
- any는 함수 시그니처(contract)를 무시한다.
- any 타입에는 언어 서비스가 적용되지 않음. Rename Symbol같은 이름 변경 서비스 이용불가.
- any 타입은 코드 리팩터링 때 버그를 감춘다.

  **요약: any 타입은 타입체커와 타입스크립트 언어 서비스를 무력화시켜 버린다. 따라서 진짜 문제점을 감추며, 개발경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨립니다. 최대한 사용을 피하도록.**

# 2장

ts에 가장 중요한 역할은 타입시스템. 어떻게 사용하고, 무엇을 결정해야하며, 가급적 사용하지 말아야 할 기능 중점적으로.

## 아이템6. 편집기를 사용하여 타입 시스템 탐색하기

- tsc: 타입스크립트 컴파일러
- tsserver: 단독으로 실행 가능한 타입스크립트 서버 언어서비스(코드 자동완성, 명세 specification, 검사, 검색, 리팩터링)
- 편집기에서 타입스크립트 언어 서비스를 적극 활용하여, 타입 시스템이 어떻게 동작하는지 어떻게 타입을 추론하는지 개념을 잡자.
- 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야함.

## 아이템7. 타입이 값들의 집합이라고 생각하기

never < unit type,literal < union

- 집합의 관점에서 타입체커의 주요기능은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것.
- 타입을 값의 집합으로 생각하면 이해하기 쉬움. 이 집합은 유한(boolean or literal type)하거나 무한(number or string)한다.
- 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현됨. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
- 타입의 연산은 집합의 범위에 적용됩니다. A와 B의 인터섹션(교집합)은 A의 범위와 B의 범위의 인터섹션입니다. 객체 타입에서는 A&B인 값이 A와 B의 속성을 모두 가짐을 의미.

## 아이템8. 타입 공간과 값 공간의 심벌 구분하기

- 타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.
- 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용.
- 타입의 속성을 얻을 때에는 반드시 obj['field']를 사용해야 함.
- 값에서 &와 |는 AND와 OR 비트연산.타입에서는 인터섹션과 유니온.
- const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론 타입을 바꿉니다.

### 요약

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분.
- 모든 값은 타입을 갖지만, 타입은 값을 가지지 않음. type, interface 같은 키워드는 타입 공간에서만 존재
- class나 enum같은 키워드는 타입과 값 두 가지로 사용가능.
- "foo"는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입공간, 값공간에서 다른 목적으로 사용될 수 있다.

## 아이템9. 타입 단언보다는 타입 선언을 사용하기

- 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것임. 속성을 추가할 때도.
- 타입 단언(as Type)이 꼭 필요한 경우가 아니라면, 안정성 체크도 되는 타입 선언(: Type)을 사용.

```ts
const people: Person[] = ['alice', 'bob', 'jan'].map(
    (name): Person => ({name})
); // 타입은 Person[]
```

- 타입 단언은 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 사용. 예) DOM 엘리먼트 등..
- 화살표 함수의 반환 타입을 명시하는 방법을 터득
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황이라면 타입 단언문과 null 아님 단언문을 사용.

## 아이템10. 객체 래퍼 타입 피하기

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 알아야함. 직접 사용이나 인스턴스 생성은 피하자.
- 객체 래퍼 타입은 지양. 대신 기본형 타입을 사용해야 함. 예) String 대신 string, Number 대신 number.

## 아이템11. 잉여 속성 체크의 한계 인지하기

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됨.
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, ts 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다름.
- 잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템12. 함수 표현식에 타입 적용하기

```ts
declare function fetch(
    input: RequestInfo, init?: RequestInit
): Promise<Response>

const checkedFetch: typeof fetch = async (input, init) => {
    const response = await fetch(input, init);
    if (!response.ok) {
        // 비동기 함수 내에서 거절된 프로미스로 변환
        throw new Error('Request failed: ' + response.status);
    }
    return response;
}
```

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보기. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 한다.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용.

## 아이템 13. 타입과 인터페이스의 차이점 알기

- 인터페이스는 유니온 타입같은 복잡한 타입을 확장하지는 못함. 복잡한 타입을 확장하고 싶다면 타입과 &을 사용해야함.
- 클래스 구현(implements)할 때는, 타입과 인터페이스 둘 다 사용가능.

```ts
// 듀플과 배열 타입은 type 키워드로 보다 간결하게 표현 가능.
type Pair = [number, number];
type StringList = string[];
type NameNums = [string, ...number[]];
```

```ts
// 인터페이스는 타입에는 없는 몇 가지 기능 존재. 보강(augment)이 가능. 선언 병합(declaration merging)
interface State {
    name: string;
    capital: string;
}

interface State {
    population: number;
}

const wyoming: State = {
    name: 'Wyoming',
    capital: 'Cheyenne',
    population: 500_000
}; //정상
```

- 복잡한 타입이라면 고민할 필요없이 type 사용. 하지만 간단한 객체 타입이라면 일관성과 보강의 관점에서 interface 고려도 필요.
- 즉, 프로젝트 스타일에 맞춰 사용.
- 스타일이 확립되지 않은 프로젝트라면 어떤 API에 대한 타입 선언을 작성해야한다면 interface를 사용하는 것이 좋음. API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합할 수 있어 유용.
- 그러나 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계. 따라서 이럴땐 type을 사용.